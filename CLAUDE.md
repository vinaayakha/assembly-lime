# Assembly Lime — Software Factory POC

## Project Overview

Assembly Lime is a multi-tenant software factory dashboard where PM/Dev/QA collaborate on planning and execution with AI agents (OpenAI Codex + Claude Agent SDK), connected to an org's GitHub repositories and deployment pipelines.

**Core UX surfaces:**
- **Command Center** — Chat-first prompt interface with model/provider selector, streaming transcript, artifact viewer (diffs, PR links, test output)
- **Kanban Board** — Jira-like columns: `Backlog > Todo > In Progress > Code Review > QA > Done` with drag/drop, ticket drawers
- **GitHub integration** — Repo connections, PR status, GitHub Actions workflow visibility
- **AI Agents** — Modes: `plan`, `implement`, `bugfix`, `review`. Outputs: ticket plans + diffs + PRs, all auditable
- **Feature Map** — Searchable feature-to-repository mapping so agents auto-plan changes across all affected repos

## Tech Stack

- **Runtime:** Bun (api, claude worker); Node 24 via nvm (web/Vite, codex worker)
- **Language:** TypeScript everywhere
- **API framework:** Elysia (Bun-native)
- **Frontend:** React + Vite + Tailwind + Radix UI, drag/drop via `@dnd-kit`
- **Database:** PostgreSQL 16 via Drizzle ORM
- **Queue:** BullMQ + Redis
- **Auth:** GitHub OAuth + session cookies (GitHub App later)
- **Realtime:** WebSocket (Bun-native) + Redis pub/sub
- **Logging:** pino with request IDs and run IDs

## Target Monorepo Layout

```
assembly-lime/
  apps/
    web/                  # React + Vite frontend
    api/                  # Bun + Elysia API server
    worker-claude/        # Bun + Claude Agent SDK
    worker-codex/         # Node 20 + Codex SDK
  packages/
    shared/               # Types, Zod schemas, event protocol
  infra/
    docker-compose.yml
    k8s/                  # Optional stubs
  docs/
    drm.md
    api.md
    threat-model.md
    secret-management.md
    hook-sandboxing.md
    budget-enforcement.md
    data-retention.md
    runbooks.md
```

## Tooling Conventions

- **Always use `bun` CLI for scaffolding** — use `bun init`, `bun create`, `bun add` instead of npm/yarn/pnpm equivalents
- **Bun workspaces** for monorepo management (configured via root `package.json` `workspaces` field)
- **`bun create vite`** for new frontend apps (React + Vite)
- **`bun init`** for new backend apps and packages
- **`bun add`** for installing dependencies (`bun add -d` for devDependencies)

## Critical Rules

### Database Conventions (REQUIRED)
- **Primary keys:** `BIGINT GENERATED BY DEFAULT AS IDENTITY` — NO UUIDs anywhere
- **All timestamps:** `timestamptz`
- **Multi-tenant:** Every row is tenant-scoped via `tenant_id` FK
- **Extensions:** `citext` (emails), `pgcrypto` (hash/random), `pg_trgm` (fuzzy search)
- **Deletion:** `ON DELETE CASCADE` for tightly owned records; soft delete for sensitive entities (connectors, api_keys)
- **IDs over the wire:** All bigint IDs serialized as **strings** in API/WS JSON payloads (JS BigInt is not JSON-serializable)

### Security (REQUIRED)
- Never store secrets in DB unencrypted — use envelope encryption (libsodium + `ENCRYPTION_MASTER_KEY` env var)
- Never execute user hooks outside a sandbox container (no host FS, no network by default)
- Never send secrets to agents in plain text
- Never log secrets
- Agent workers run in containers with limited FS and network access
- All API inputs validated with Zod

### Agent Protocol
- Every worker must emit structured `AgentEvent`s (message, log, diff, artifact, error)
- API persists all events into `agent_events` table
- Events broadcast to UI via WebSocket
- Claude agent: enforce `allowedTools` per run
- Codex agent: constrain via isolated container + repo allowlist

## Data Model (DRM Entities)

All tenant-scoped. Full schema in `assembly-lime-poc-plan-v2.md` section 5.

**Core:** tenants, users, roles, user_roles
**Projects:** projects, boards, tickets
**Connectors:** connectors, repositories, webhooks
**Features (v3):** features, feature_repository_map, feature_aliases, repository_aliases, project_repositories
**Agent:** agent_runs, agent_events, code_diffs, audit_log
**Config:** hooks, custom_instructions, default_agent_instructions, default_agent_tools
**Infra:** build_pipelines, pipeline_runs, deployment_targets, deployments, deployment_steps
**Security:** api_keys, env_var_sets, env_vars, project_budgets

## Provider Abstraction

Shared types live in `packages/shared/src/protocol.ts`:
- `AgentProviderId`: `"codex" | "claude"`
- `AgentMode`: `"plan" | "implement" | "bugfix" | "review"`
- `AgentRunRequest`: run config with repo info, constraints, ticket context
- `AgentEvent`: union type for message/log/diff/artifact/error events

## Agent Data Flow

1. UI requests agent run: `POST /agent-runs`
2. API creates `agent_runs` row, enqueues job in Redis (BullMQ)
3. Worker pulls job, clones repo, runs agent, emits streaming `agent_events`
4. API persists events + broadcasts to UI via WebSocket
5. On completion: store diff in `code_diffs`, artifacts, PR link, test results

## Instruction Resolution Order

When building the system prompt for an agent run:
1. `default_agent_instructions` (tenant + provider)
2. `custom_instructions` for tenant scope
3. `custom_instructions` for project scope
4. `custom_instructions` for repository scope
5. `custom_instructions` for ticket scope
6. User prompt

## Feature Map (v3 — Multi-Repo Planning)

When a user requests "create/update feature X", the planning agent must:
1. Search `features.search_text` + `feature_aliases` for the feature
2. Retrieve mapped repositories from `feature_repository_map`
3. Produce a plan grouped by repository (backend/frontend/SDK/pipeline)
4. Include deployment work if pipeline_repo or infra repos are mapped
5. Include version bump matrix for SDK/package repos if touched

Fallback when feature not found: use `project_repositories` and match repo roles to keywords in the prompt.

## Implementation Milestones

- **A** — Postgres schema + Drizzle migrations (all DRM tables + indexes + seed roles)
- **B** — Auth + tenant bootstrap (GitHub OAuth, auto-create tenant, assign admin)
- **C** — Board CRUD + realtime (ticket CRUD, drag/drop, WS broadcasting)
- **D** — Repos/connectors + webhooks (connect repos, webhook receiver)
- **E** — Agent runs + events + code diffs (queue orchestration, budget enforcement)
- **F** — Hooks + custom instructions (instruction resolution engine, hook sandbox)

## Environment Variables

```
DATABASE_URL=postgres://...
REDIS_URL=redis://...
GITHUB_CLIENT_ID=...
GITHUB_CLIENT_SECRET=...
OPENAI_API_KEY=...
ANTHROPIC_API_KEY=...
ENCRYPTION_MASTER_KEY=...
```

## Development

The app is called **assemblyLime**. The user runs all services themselves — do NOT attempt to start, stop, restart, or check running processes. Do NOT run `bun dev`, `bun dev:all`, `lsof`, `ps`, or any process inspection commands. Assume the API, web frontend, and workers are already running when the user is testing.

```bash
bun install          # Install dependencies
bun dev:all          # Start all services (API + web + workers)
bun db:push          # Apply schema changes (db:migrate has permission issues on managed DB)
bun db:seed          # Seed dev data
```

**Ports:**
- `3434` — API (Bun + Elysia)
- `5173` — Frontend (Vite dev server, proxies `/api` → `:3434`)

## Reference Documents

- `assembly-lime-poc-plan.md` — Original POC plan (architecture, UI spec, agent prompts, milestone sequence)
- `assembly-lime-poc-plan-v2.md` — Full Postgres-optimized DRM schema, API routes, provider abstraction
- `assembly-lime-poc-plan-v3.md` — Multi-repo projects, feature map, deployments, search optimization
